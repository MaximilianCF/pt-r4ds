# Quarto {#sec-quarto}

```{r}
#| echo: false

source("_common.R")
```

## Introduction

Quarto fornece uma estrutura (*framework*) unificada para autoria em ciência de dados, combinando seu código, seus resultados e sua prosa.
Documentos Quarto são plenamente reproduzíveis e suportam muitos formatos de saída como PDF, arquivos Word, apresentações e mais.

Arquivos Quarto foram projetados para serem usados de três maneiras:

1.  Para se comunicar com pessoas tomadoras de decisões, que querem focar nas conclusões e não no código por trás da análise.

2.  Para colaborar com outros cientistas de dados (incluindo futuramente você!) que estejam interessados tanto em suas conclusões quanto em como você as alcançou (isto é, o código).

3.  Como um ambiente em que se *faz* ciência de dados, como um caderno de laboratório moderno em que se pode capturar não apenas o que você fez, como também o que você estava pensando.

Quarto é uma feerramenta de linha de comando, não é um pacote do R.
Isso significa que ajuda, via de regra, não está disponível via `?`.
Em vez disso, enquanto você trabalhar neste capítulo e usa Quarto no futuro, você deve procurar a [documentação para Quarto](https://quarto.org).

Se você for uma pessoa que usa R Markdown, você deve estar pensando "Quarto parece muito com R Markdown".
Isso não está errado!
Quarto une a funcionalidade de muitos pacotes do ecosistema do R Markdown (rmarkdown, bookdown, distill, xaringan, etc.) em um sistema único e consistente, mas também extende o ecosistema com apoio nativo para múltiplas linguagens de programação como Python e Julia, além do próprio R.
De certa forma, Quarto reflete tudo que foi aprendido na expansão e suporte ao ecosistema do R Markdown em uma década.

### Pré-requisitos

Você precisa da interface de linha de comando Quarto (Quarto CLI -- *command line interface*), mas não é necessário explicitamente instalar ou carregá-la.
Seu RStudio o fará automaticamente quando for necessário.

```{r}
#| label: setup
#| include: false

chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
library(tidyverse)
```

## Básico de Quarto

Isso é um arquivo Quarto -- This is a Quarto file -- um arquivo de texto simples que possui a extensão `.qmd`:

```{r echo = FALSE, comment = ""}
cat(readr::read_file("quarto/diamond-sizes.qmd"))
```

O arquivo contém três tipos importantes de conteúdo:

1.  Um **cabeçalho YAML** (opcional) envolto por `---`.
2.  **Blocos** (ou *chunks*) de código R envoltos por ```` ``` ````.
3.  Texto misturado com formatação simples de texto como `# heading` and `_italics_` (respectivamente, para denotar um título ou marcar texto como itálico).

@fig-diamond-sizes-notebook mostra um documento `.qmd` no RStudio com interface de caderno, no qual código e saída são intercalados.
Você pode executar cada bloco de código clicando no ícone Executar -- *Run* (triângulo verde que parece com o botão de play no canto superior direito do bloco), ou pressionando Cmd/Ctrl + Shift + Enter.
O RStudio executará o código e mostrará os resultados junto com o código.

```{r}
#| label: fig-diamond-sizes-notebook
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio. Code and output interleaved in 
#|   the document, with the plot output appearing right underneath the code.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and a blank Viewer window on the right. The Quarto 
#|   document has a code chunk that creates a frequency plot of diamonds 
#|   that weigh less than 2.5 carats. The plot shows that the frequency 
#|   decreases as the weight increases.

knitr::include_graphics("quarto/diamond-sizes-notebook.png")
```

Se você não gosta de ver seus gráficos e saída dos códigos no documento e prefere usar os painéis de console e gráfico (aba *plot*), é possível clicar no ícone de roda dentada próximo ao botão "*Render*" e selecionar "*Chunk Output in Console*" (ou seja, resultados do chunk no console), conforme mostrado em @fig-diamond-sizes-console-output.

```{r}
#| label: fig-diamond-sizes-console-output
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio with the plot output in the Plots pane.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and the Plot pane on the bottom right. The Quarto 
#|   document has a code chunk that creates a frequency plot of diamonds 
#|   that weigh less than 2.5 carats. The plot is displayed in the Plot 
#|   pane and shows that the frequency decreases as the weight increases. 
#|   The RStudio option to show Chunk Output in Console is also 
#|   highlighted.

knitr::include_graphics("quarto/diamond-sizes-console-output.png")
```

Para produzir um relatório completo contendo todo o texto, código e resultados, clique em "Render" or pressione Cmd/Ctrl + Shift + K.
Você também pode fazer isso de programaticamente, em linha de código, com `quarto::quarto_render("diamond-sizes.qmd")`.
Isso exibirá o relatório no painel de visualização, como exibido em @fig-diamond-sizes-report, e cria um arquivo HTML.

```{r}
#| label: fig-diamond-sizes-report
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio with the rendered document in the 
#|   Viewer pane.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and the Plot pane on the bottom right. The rendered 
#|   document does not show any of the code, but the code is visible 
#|   in the source document.

knitr::include_graphics("quarto/diamond-sizes-report.png")
```

Quando se gera ou renderiza o documento, Quarto envia o arquivo `.qmd` para o **knitr**, <https://yihui.org/knitr/>, que executa todos os blocos de código e cria um novo arquivo markdown (`.md`) que inclui o código e seus resultados.
O arquivo markgodn gerado pelo knitr é então processado pelo **pandoc**, [https://pandoc.org](https://pandoc.org/){.uri}, que é responsável por criar a versão final do arquivo.
Esse processo é ilustrado em @fig-quarto-flow.
A vantagem desse fluxo de trabalho em duas etapas é que é possível criar uma ampla variedade de formatos de arquivo, como você verá em @sec-quarto-formats.

```{r}
#| label: fig-quarto-flow
#| echo: false
#| out-width: "75%"
#| fig-alt: |
#|   Workflow diagram starting with a qmd file, then knitr, then md, 
#|   then pandoc, then PDF, MS Word, or HTML.
#| fig-cap: |
#|   Diagram of Quarto workflow from qmd, to knitr, to md, to pandoc, 
#|   to output in PDF, MS Word, or HTML formats.

knitr::include_graphics("images/quarto-flow.png")
```

Para iniciar seu próprio arquivo `.qmd`, selecione *File \> New File \> Quarto Document...* na barra de menu.
O RStudio abrirá uma janela em que você poderá preencher informações para pré-povoar seu arquivo com conteúdos úteis que lembra como os principais recursos do Quarto funcionam.

As seções a seguir aprofundam os três componentes de um documento Quarto em mais detalhes: o texto em markdown, os blocos de código e o cabeçalho YAML.

### Exercícios

1.  Crie um novo documento Quarto usando *File \> New File \> Quarto Document*.
    Leia as instruções.
    Pratique a execução dos blocos de código individualmente.
    Depois, renderize o documento clicando no botão designado e depois usando o atalho do teclado.
    Verifique se consegue alterar o código, rodá-lo novamente e ver o novo documento modificado.

2.  Crie um novo documento Quarto para cada um dos três formatos disponibilizados: HTML, PDF e Word.
    Renderize cada um dos três documentos.
    Qual é a diferença entre os resultados?
    Qual é a diferença entre os insumos?
    (É possível que seja necessário instalar o LaTeX para construir o arquivo PDF --- O RStudio avisará se isso for necessário.)

## Editor Visual

O editor Visual no RSTUDIO utiliza uma interface [WYSIWYM](https://en.wikipedia.org/wiki/WYSIWYM) para autoria de documentos Quarto.
Dembaixo do capô, prosa em documentos Quarto (arquivos `.qmd`) são escritos em Markdown, um conjunto leve de convenções para formatação de arquivos de texto simples.
De fato, Quarto usa markdown Pandoc (uma versão um pouco extendida de Markdown que é interpretável pelo Quarto), incluindo tabelas, citações, referências cruzadas, notas de rodapé, divs/spans, definiçòes de listas, atributos, HTML/TeX crús, entre outros, assim como suporta execução de células de código e a visualização de seus resultados em linha.
Enquanto Markdown é desenhado para ser simples de ler e escrever, como você verá em @sec-source-editor, ainda é necessário aprender uma nova sintaxe.
Assim, se documentos computacionais como arquivos `.qmd` são novos para você, mas você tem experiência com Google Docs ou MS Word, o jeito mais fácil de começar a usar Quarto no RStudio é pelo editor visual.

No editor visual, você pode tanto usar botões na barra de menu para inserir imagens, tabelas, referências cruzadas, etc. quanto usar o atalho geral <kbd>⌘ /</kbd> para inserir qualquer coisa.
Se você estiver no começo de uma linha (como ilustrado em @fig-visual-editor), você pode apenas digitar para <kbd>/</kbd> invocar o atalho.

```{r}
#| label: fig-visual-editor
#| echo: false
#| out-width: "75%"
#| fig-cap: |
#|   Quarto visual editor.
#| fig-alt: |
#|   A Quarto document displaying various features of the 
#|   visual editor such as text formatting (italic, bold, 
#|   underline, small caps, code, superscript, and subscript),
#|   first through third level headings, bulleted and numbered
#|   lists, links, linked phrases, and images (along with a 
#|   pop-up window for customizing image size, adding a 
#|   caption and alt text, etc.), tables with a header row, 
#|   and the insert anything tool with options to insert an 
#|   R code chunk, a Python code chunk, a div, a bullet list, 
#|   a numbered list, or a first level heading (the top few 
#|   choices in the tool).

knitr::include_graphics("quarto/quarto-visual-editor.png")
```

Inserir e personalizar como são exibidos também é facilitado com o uso do editor visual.
Você pode colar uma pasta diretamente da sua área de transferência no editor visual (e o RStudio colocará uma cópia daquela imagem no diretório do projeto e montarará um link para ela) ou usar o menu Insert \> Figure / Image do editor visual para navegar até a imagem desejada para inserir ou colar sua URL.
Além disso, usando o mesmo menu você pode redimensionar a imagem e aditionar uma legenda, texto alternativo e um link.

O editor visual tem muito mais recursos que não enumeramos aqui que podem ser úteis a você na medida em que você ganha experiência em escrever com a ferramenta.

Mais importante, enquanto o editor visual exibe o conteúdo do documento com formatação, por trás ele salva o conteúdo em Markdown, permitindo transitar entre o editor visual e de código (*source*) para visualizar e editar o documento usando qualquer uma das ferramentas.

### Exercícios

1.  Crie novamente o documento em @fig-visual-editor usando o editor visual.
2.  Usando o editor visual, insira um bloco de código usando o menu Insert e depois faça o mesmo usando qualquer ferramenta.
3.  Usando o editor visual, descubra como:
    a.  Adicionar uma nota de rodapé.
    b.  Adicionar uma linha horizontal.
    c.  Adicionar um bloco de citação.
4.  Usando o editor visual, vá em Insert \> Citation e insira a citação para o artigo cujo título é [Welcome to the Tidyverse](https://joss.theoj.org/papers/10.21105/joss.01686) usando o DOI (*digital object identifier*), que é [10.21105/joss.01686](https://doi.org/10.21105/joss.01686). Renderize o documento e observe como a referencia aparece no documento. Que alteração você consegue identificar no YAML do seu documento?

## Editor Source {#sec-source-editor}

Também é possível editar documentos Quarto usando o editor Source no RStudio, sem a assistência do editor visual.
Enquanto o editor Visual será familiar para aqueles com experiência em escrita com ferramentas como Google docs, o editor Source será familia para aqueles com experiência escrevendo scripts R ou documentos R Markdown.
O editor Source também pode ser útil para correções (*debugging*) qualquer erro de sintaxe Quarto, já que muitas vezes é mais fácil achar esses erros em texto simples.

O guia abaixo mostra como usar o Markdown do Pandoc para escrever documentos Quarto em seu editor fonte.

```{r}
#| echo: false
#| comment: ""

cat(readr::read_file("quarto/markdown.qmd"))
```

A melhor forma de aprender essas coisas é simplesmente tentar.
Isso levará alguns dias, mas em pouco tempo se tornam algo automático e não será necessário pensar tanto sobre elas.
Se você se esquecer, pode buscar uma boa folha de referência em *Help \> Markdown Quick Reference*.

### Exercícios

1.  Pratique o que você aprendeu criando um CV breve.
    O título deve ser o seu nome e você deve incluir cabeçalhos para pelo menos sua educação e trabalho.
    Cada uma das seções deve incluir uma lista em tópicos de trabalhos/títulos.
    Destaque o ano em negrito.

2.  Usando o editor fonte e a referência rápida para Markdown, descubra como:

    a.  Adicionar uma nota de rodapé.
    b.  ADicionar uma linha horizontal.
    c.  Adicionar um bloco de citação.

3.  Copie e cole o conteúdo de `diamond-sizes.qmd` a partir de <https://github.com/hadley/r4ds/tree/main/quarto> para um arquivo R Quarto local.
    Verifique se você consegue executá-lo, depois adicione texto depois do polígono de frequências que descreve suas características mais chamativas.

4.  Crie um documento em Google doc ou MS Word (ou localize um documento que você tenha criado previamente) que contenha títulos, hiperlinks, texto formatado, etc.
    Copie os conteúdos desse documento e cole-os em um documento quarto no editor visual.
    Em seguida, troque para o editor source e inspecion o código fonte.

## Blocos de Código

Para executar código em um documento Quarto, é necessário incluir um bloco de código.
Há três maneiras de fazer isso:

1.  O atalho de teclado Cmd + Option + I / Ctrl + Alt + I.

2.  O botão "Insert" na barra de ferramentas do editor.

3.  Escrevendo manualmente os limitadores de bloco ```` ```{r} ```` e ```` ``` ````.

Recomandamos que você aprenda o atalho de teclado.
Isso economizará muito tempo no longo prazo!

É possível prosseguir para a execução do código usando o atalho que agora (temos fé!) que você conhece e ama:Cmd/Ctrl + Enter.
No entanto, blocos recebem um novo atalho: Cmd/Ctrl + Shift + Enter, que executa todo o código no bloco.
Pense no bloco de código como uma função.
Um bloco deve ser relativamente autocontido, objetivando uma única tarefa.

As seções a seguir descrevem o cabeçalho do bloco, que consiste em ```` ```{r} ````, seguido de um rótulo opcional e diversas outras opções de bloco, cada uma em sua própria linha, marcada por `#|`.

### Rótulo de bloco

Blocos podem receber um rótulo opciona, por exemplo

```{r}
#| echo: fenced
#| label: simple-addition

1 + 1
```

Há três vantagens nisso:

1.  É possível navegar mais facilmente para blocos específicos usando o navegador em lista no canto inferior esquerdo do editor do script:

    ```{r}
    #| echo: false
    #| out-width: "30%"
    #| fig-alt: |
    #|   Snippet of RStudio IDE showing only the drop-down code navigator 
    #|   which shows three chunks. Chunk 1 is setup. Chunk 2 is cars and 
    #|   it is in a section called Quarto. Chunk 3 is pressure and it is in 
    #|   a section called Including plots.

    knitr::include_graphics("screenshots/quarto-chunk-nav.png")
    ```

2.  Gráficos produzidos pelos blocos terão nomes úteis para reutilizá-los em outros lugares.
    Mais sobre isso em @sec-figures.

3.  É possível organizar redes de bloco em cache para evitar múltiplas execuções de computações caras em toda execução.
    Mais sobre isso em @sec-caching.

Os rótulos dos seus blocos devem ser curtos, mas evocativos e não devem conter espaços.
Recomendamos o uso de traços (`-`) para separar palavras (em vez de sublinhados, `_`) e evitar o uso de outros caracteres especiais nos rótulos de código.

Em geral você é livre para rotular o bloco de código como quiser, mas há um bloco cujo nome indica um coportamento especial: `setup`.
Quando você está no modo caderno, o bloco com nome *setup* será executado automaticamente uma vez antes que todo o seu código seja executado.

Além disso,rótulos não podem ser duplicados.
Cada rótulo de bloco deve ser único.

### Opções de bloco

Saídas de bloco podem ser personalizadas com campos de opções (**options**) fornecidos para o cabeçalho do bloco.
Quase 60 opções para personalização dos seus blocos de código são fornecidas pelo Knitr.
Aqui cobriremos as opções mais importantes, que você utilizará com frequência.
É possível verificar a lista completa em [https://yihui.org/knitr/options](https://yihui.org/knitr/options/){.uri}.

O conjunto mais importante de opçòes controla se seu código será executado e que resultados serão exibidos no relatório final:

-   `eval: false` previne o código de ser avaliado.
    (E obviamente, se o código não é executado, nenhum resultado será gerado).
    Isso é útil para exibir um código de exemplo ou para desabilitar um grande bloco de código sem comentar cada uma de suas linhas.

-   `include: false` executa o código, mas não o mostra nem inclui seus resultados no documento final.
    Use isso para códigos de configurações cujos resultados você não quer que dêem uma aparência de desordem no seu relatório.

-   `echo: false` evita o código mas permite a exibição dos resultados no arquivo finalizado.
    Use isso quando estiver escrevendo relatórios direcionados a pessoas que não querem ver o código por trás dos resultados.

-   `message: false` ou `warning: false` previne o aparecimento de mensagens ou avisos no arquivo final.

-   `results: hide` esconde output; `fig-show: hide` esconde gráficos.

-   `error: true` permite a renderização contínua do seu documento mesmo que ocorra um erro.
    Você raramente precisará incluir isso na versão final do seu relatório, mas pode ser útil se você precisa corrigir um erro específico dentro do seu `.qmd`.
    Também é útil se você está ensinando R e quer incluir um erro deliberadamente.
    O padrão, `error: false` impede a renderização caso exista qualquer erro no documento.

Cada uma dessas opções de bloco é adicionada ao cabeçalho do bloco, seguindo `#|`, por exemplo, no bloco a seguir o resultado não é impresso, já que `eval` está marcado como *false*.

```{r}
#| echo: fenced
#| label: simple-multiplication
#| eval: false

2 * 2
```

A tabela a seguir resume que tipos de output cada opção suprime:

| Opção            | Executa código | Mostra código | Output | Gráficos | Mensagens | Avisos |
|------------------|:--------------:|:-------------:|:------:|:--------:|:---------:|:------:|
| `eval: false`    |       X        |               |   X    |    X     |     X     |   X    |
| `include: false` |                |       X       |   X    |    X     |     X     |   X    |
| `echo: false`    |                |       X       |        |          |           |        |
| `results: hide`  |                |               |   X    |          |           |        |
| `fig-show: hide` |                |               |        |    X     |           |        |
| `message: false` |                |               |        |          |     X     |        |
| `warning: false` |                |               |        |          |           |   X    |

### Opções Globais

Na medida em que você trabalhar mais com o knitr, você descobrirá que algumas das opções padrão dos blocos não satisfazem a sua necessidade e será preciso alterá-las.

É possível fazer isso adicionando suas opções preferidas no YAML do documento em `execute`.
Por exemplo, se você estiver preparando um relatório para uma audiência que não precisa ver seu código, mas apenas seus resultados e narrativa, pode ser que seja desejável configurar `echo: false` no nível do documento.
Isso esconderá o código por padrão e só exibirá blocos de código que você escolha mostrar ( com `echo: true`).
Você pode configurar `message: false` e `warning: false`, mas isso tornará difícil a resolução de problemas de execução porque nenhuma das mensagens srão exibidas no final do documento.

``` yaml
title: "My report"
execute:
  echo: false
```

Como Quarto foi desenhado para ser multi-línguas (funciona com R mas também com outras linguagens como Python, Julia, etc.), nem todas as opções do knitr estão disponíveis no nível de documento.
Algumas das opçoes funcionam com knitr mas não com outros motores (*engines*) que o Quarto usa para executar código em outras linguagens (por exemplo, Jupyter).
No entanto é possível ajustar essas como opções globais para o seu documento dentro do campo `knitr` em `opts_chunk`.
Por exemplo, quando escrevemos livros ou tutoriais, configuramos:

``` yaml
title: "Tutorial"
knitr:
  opts_chunk:
    comment: "#>"
    collapse: true
```

Isso faz com que nossa formatação para comentários preferida seja usada e garante que o código e seu resultado sejam exibidos próximos um do outro.

### Código em linha

Existe outra maneira de inserir código R em um documento Quarto: diretamente no texto com `r inline()`.
Isso pode ser muito útil se você for citar propriedades dos seus dados no texto.
Por exemplo, o documento modelo usado no começo do capítulo tinh:

> Temos dados sobre `r inline('nrow(diamonds)')` diamantes.
> Apenas `r inline('nrow(diamonds) - nrow(smaller)')` são maiores que 2.5 carates.
> A distribuição dos restantes é exibida abaixo:

Quando o relatório é renderizado, os resultados dessas computações são inseridas no texto:

> Temos dados sobre 53940 diamantes.
> Apenas 126 são maiores que 2.5 carates.
> A distribuição dos restantes é exibida abaixo:

Ao inserir números no texto, `format()` é seu amigo.
A função permite configurar o número de `digits` (casas decimais) para que você não imprima o número com uma precisão ridícula e `big.mark` para facilitar a leitura dos números.
Você pode combiná-las em uma função auxiliar:

```{r}
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.12358124331)
```

### Exercícios

1.  Adicione uma seção que explore como o tamanho de diamantes varia de acordo com corte, cor e claridade.
    Considere que você está escrevendo um relatório para alguém que não sabe R e em vez de usar `echo: false` em cada bloco, configure como uma opção global.

2.  Faça o download de `diamond-sizes.qmd` de <https://github.com/hadley/r4ds/tree/main/quarto>.
    Adicione uma seção que descreva os 20 maiores diamantes, incluindo uma tabela que mostre seus atributos mais importantes.

3.  Modifique `diamonds-sizes.qmd` para usar `label_comma()` e produzir output bem formatado.
    Inclua tam´bme a percentagem de diamantes que são maiores que 2.5 carates.

## Figuras {#sec-figures}

As figuras em um documento Quarto podem ser integradas (como um arquivo PNG ou JPEG) ou geradas como resultado de um bloco de código.

Para integrar uma imagem a partir de um arquivo externo, é possível usar o menu Insert no editor Visual no RStudio e selecionar Figure / Image.
Isso abrirá um menu em que é possível buscar a imagem que você deseja inserir, assim como adicionar um texto alternativo ou legenda e ajustar seu tamanho.

No editor visual também é possível simplesmente colar uma imagem da sua área de transferência no documento, então o RStudio inserirá uma cópia daquela imagem na pasta do seu projeto.

Se você incluir um bloco de código que gera uma figura (como uma chamada a `ggplot()`), a imagem resultante será automaticamente incluída no seu documento Quarto.

### Tamanho de figura

O maior desafio ao trabalhar com imagens no Quarto é fazer com que elas fiquem do tamanho e no formato corretos.
Há cinco opções principais que controlam o tamanho da figura: `fig-width`, `fig-height`, `fig-asp`, `out-width` e `out-height`.
Ajustar o tamanho é desafiador porque há dois tamanhos (aquele da figura criada pelo R e aquele que é inserido no documento final) e múltiplas formas de especificar tamanho (isto é, altura, largura e proporcional ou *aspect ratio*: escolha dois dos três).

Recomendamos três das cinco opções:

-   Gráficos tendem a ser esteticamente mais agradáveis se têm largura consistente.
    Para garantir isso, configure `fig-width: 6` (6 polegadas) and `fig-asp: 0.618` (a razão áurea) nas definições padrão.
    Nos blocos individuais, ajuste apenas `fig-asp`.

-   Controle o tamanho da saída com `out-width` e configure como uma percentagem da largura do corpo do documento.
    Sugerimos `out-width: "70%"` e `fig-align: center`.

    Isso dá espaço para os gráficos respirarem, sem tomar espaço demais.

-   To put multiple plots in a single row, set the `layout-ncol` to 2 for two plots, 3 for three plots, etc.
    This effectively sets `out-width` to "50%" for each of your plots if `layout-ncol` is 2, "33%" if `layout-ncol` is 3, etc.
    Depending on what you're trying to illustrate (e.g., show data or show plot variations), you might also tweak `fig-width`, as discussed below.

If you find that you're having to squint to read the text in your plot, you need to tweak `fig-width`.
If `fig-width` is larger than the size the figure is rendered in the final doc, the text will be too small; if `fig-width` is smaller, the text will be too big.
You'll often need to do a little experimentation to figure out the right ratio between the `fig-width` and the eventual width in your document.
To illustrate the principle, the following three plots have `fig-width` of 4, 6, and 8 respectively:

```{r}
#| include: false

plot <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()
```

```{r}
#| echo: false
#| fig-width: 4
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are normally sized and the axis text and labels are in similar font size 
#|   to the surrounding text.

plot
```

```{r}
#| echo: false
#| fig-width: 6
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are smaller than in the previous plot and the axis text and labels are 
#|   smallter than the surrounding text.

plot
```

```{r}
#| echo: false
#| fig-width: 8
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are even smaller than in the previous plot and the axis text and labels are 
#|   even smallter than the surrounding text.

plot
```

If you want to make sure the font size is consistent across all your figures, whenever you set `out-width`, you'll also need to adjust `fig-width` to maintain the same ratio with your default `out-width`.
For example, if your default `fig-width` is 6 and `out-width` is "70%", when you set `out-width: "50%"` you'll need to set `fig-width` to 4.3 (6 \* 0.5 / 0.7).

Figure sizing and scaling is an art and science and getting things right can require an iterative trial-and-error approach.
You can learn more about figure sizing in the [taking control of plot scaling blog post](https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/).

### Other important options

When mingling code and text, like in this book, you can set `fig-show: hold` so that plots are shown after the code.
This has the pleasant side effect of forcing you to break up large blocks of code with their explanations.

To add a caption to the plot, use `fig-cap`.
In Quarto this will change the figure from inline to "floating".

If you're producing PDF output, the default graphics type is PDF.
This is a good default because PDFs are high quality vector graphics.
However, they can produce very large and slow plots if you are displaying thousands of points.
In that case, set `fig-format: "png"` to force the use of PNGs.
They are slightly lower quality, but will be much more compact.

It's a good idea to name code chunks that produce figures, even if you don't routinely label other chunks.
The chunk label is used to generate the file name of the graphic on disk, so naming your chunks makes it much easier to pick out plots and reuse in other circumstances (e.g., if you want to quickly drop a single plot into an email).

### Exercises

1.  Open `diamond-sizes.qmd` in the visual editor, find an image of a diamond, copy it, and paste it into the document. Double click on the image and add a caption. Resize the image and render your document. Observe how the image is saved in your current working directory.
2.  Edit the label of the code chunk in `diamond-sizes.qmd` that generates a plot to start with the prefix `fig-` and add a caption to the figure with the chunk option `fig-cap`. Then, edit the text above the code chunk to add a cross-reference to the figure with Insert \> Cross Reference.
3.  Change the size of the figure with the following chunk options, one at a time, render your document, and describe how the figure changes.
    a.  `fig-width: 10`

    b.  `fig-height: 3`

    c.  `out-width: "100%"`

    d.  `out-width: "20%"`

## Tables

Similar to figures, you can include two types of tables in a Quarto document.
They can be markdown tables that you create directly in your Quarto document (using the Insert Table menu) or they can be tables generated as a result of a code chunk.
In this section we will focus on the latter, tables generated via computation.

By default, Quarto prints data frames and matrices as you'd see them in the console:

```{r}
mtcars[1:5, ]
```

If you prefer that data be displayed with additional formatting you can use the `knitr::kable()` function.
The code below generates @tbl-kable.

```{r}
#| label: tbl-kable
#| tbl-cap: A knitr kable.

knitr::kable(mtcars[1:5, ], )
```

Read the documentation for `?knitr::kable` to see the other ways in which you can customize the table.
For even deeper customization, consider the **gt**, **huxtable**, **reactable**, **kableExtra**, **xtable**, **stargazer**, **pander**, **tables**, and **ascii** packages.
Each provides a set of tools for returning formatted tables from R code.

### Exercises

1.  Open `diamond-sizes.qmd` in the visual editor, insert a code chunk, and add a table with `knitr::kable()` that shows the first 5 rows of the `diamonds` data frame.
2.  Display the same table with `gt::gt()` instead.
3.  Add a chunk label that starts with the prefix `tbl-` and add a caption to the table with the chunk option `tbl-cap`. Then, edit the text above the code chunk to add a cross-reference to the table with Insert \> Cross Reference.

## Caching {#sec-caching}

Normally, each render of a document starts from a completely clean slate.
This is great for reproducibility, because it ensures that you've captured every important computation in code.
However, it can be painful if you have some computations that take a long time.
The solution is `cache: true`.

You can enable the Knitr cache at the document level for caching the results of all computations in a document using standard YAML options:

``` yaml
---
title: "My Document"
execute: 
  cache: true
---
```

You can also enable caching at the chunk level for caching the results of computation in a specific chunk:

```{r}
#| echo: fenced
#| cache: true

# code for lengthy computation...
```

When set, this will save the output of the chunk to a specially named file on disk.
On subsequent runs, knitr will check to see if the code has changed, and if it hasn't, it will reuse the cached results.

The caching system must be used with care, because by default it is based on the code only, not its dependencies.
For example, here the `processed_data` chunk depends on the `raw-data` chunk:

````         
``` {{r}}
#| label: raw-data
#| cache: true

rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

````         
``` {{r}}
#| label: processed_data
#| cache: true

processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

Caching the `processed_data` chunk means that it will get re-run if the dplyr pipeline is changed, but it won't get rerun if the `read_csv()` call changes.
You can avoid that problem with the `dependson` chunk option:

````         
``` {{r}}
#| label: processed-data
#| cache: true
#| dependson: "raw-data"

processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

`dependson` should contain a character vector of *every* chunk that the cached chunk depends on.
Knitr will update the results for the cached chunk whenever it detects that one of its dependencies have changed.

Note that the chunks won't update if `a_very_large_file.csv` changes, because knitr caching only tracks changes within the `.qmd` file.
If you want to also track changes to that file you can use the `cache.extra` option.
This is an arbitrary R expression that will invalidate the cache whenever it changes.
A good function to use is `file.mtime()`: it returns when it was last modified.
Then you can write:

````         
``` {{r}}
#| label: raw-data
#| cache: true
#| cache.extra: !expr file.mtime("a_very_large_file.csv")

rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

We've followed the advice of [David Robinson](https://twitter.com/drob/status/738786604731490304) to name these chunks: each chunk is named after the primary object that it creates.
This makes it easier to understand the `dependson` specification.

As your caching strategies get progressively more complicated, it's a good idea to regularly clear out all your caches with `knitr::clean_cache()`.

### Exercises

1.  Set up a network of chunks where `d` depends on `c` and `b`, and both `b` and `c` depend on `a`. Have each chunk print `lubridate::now()`, set `cache: true`, then verify your understanding of caching.

## Troubleshooting

Troubleshooting Quarto documents can be challenging because you are no longer in an interactive R environment, and you will need to learn some new tricks.
Additionally, the error could be due to issues with the Quarto document itself or due to the R code in the Quarto document.

One common error in documents with code chunks is duplicated chunk labels, which are especially pervasive if your workflow involves copying and pasting code chunks.
To address this issue, all you need to do is to change one of your duplicated labels.

If the errors are due to the R code in the document, the first thing you should always try is to recreate the problem in an interactive session.
Restart R, then "Run all chunks", either from the Code menu, under Run region or with the keyboard shortcut Ctrl + Alt + R.
If you're lucky, that will recreate the problem, and you can figure out what's going on interactively.

If that doesn't help, there must be something different between your interactive environment and the Quarto environment.
You're going to need to systematically explore the options.
The most common difference is the working directory: the working directory of a Quarto is the directory in which it lives.
Check the working directory is what you expect by including `getwd()` in a chunk.

Next, brainstorm all the things that might cause the bug.
You'll need to systematically check that they're the same in your R session and your Quarto session.
The easiest way to do that is to set `error: true` on the chunk causing the problem, then use `print()` and `str()` to check that settings are as you expect.

## YAML header

You can control many other "whole document" settings by tweaking the parameters of the YAML header.
You might wonder what YAML stands for: it's "YAML Ain't Markup Language", which is designed for representing hierarchical data in a way that's easy for humans to read and write.
Quarto uses it to control many details of the output.
Here we'll discuss three: self-contained documents, document parameters, and bibliographies.

### Self-contained

HTML documents typically have a number of external dependencies (e.g., images, CSS style sheets, JavaScript, etc.) and, by default, Quarto places these dependencies in a `_files` folder in the same directory as your `.qmd` file.
If you publish the HTML file on a hosting platform (e.g., QuartoPub, <https://quartopub.com/>), the dependencies in this directory are published with your document and hence are available in the published report.
However, if you want to email the report to a colleague, you might prefer to have a single, self-contained, HTML document that embeds all of its dependencies.
You can do this by specifying the `embed-resources` option:

``` yaml
format:
  html:
    embed-resources: true
```

The resulting file will be self-contained, such that it will need no external files and no internet access to be displayed properly by a browser.

### Parameters

Quarto documents can include one or more parameters whose values can be set when you render the report.
Parameters are useful when you want to re-render the same report with distinct values for various key inputs.
For example, you might be producing sales reports per branch, exam results by student, or demographic summaries by country.
To declare one or more parameters, use the `params` field.

This example uses a `my_class` parameter to determine which class of cars to display:

```{r}
#| echo: false
#| out-width: "100%"
#| comment: ""

cat(readr::read_file("quarto/fuel-economy.qmd"))
```

As you can see, parameters are available within the code chunks as a read-only list named `params`.

You can write atomic vectors directly into the YAML header.
You can also run arbitrary R expressions by prefacing the parameter value with `!expr`.
This is a good way to specify date/time parameters.

``` yaml
params:
  start: !expr lubridate::ymd("2015-01-01")
  snapshot: !expr lubridate::ymd_hms("2015-01-01 12:30:00")
```

### Bibliographies and Citations

Quarto can automatically generate citations and a bibliography in a number of styles.
The most straightforward way of adding citations and bibliographies to a Quarto document is using the visual editor in RStudio.

To add a citation using the visual editor, go to Insert \> Citation.
Citations can be inserted from a variety of sources:

1.  [DOI](https://quarto.org/docs/visual-editor/technical.html#citations-from-dois) (Document Object Identifier) references.

2.  [Zotero](https://quarto.org/docs/visual-editor/technical.html#citations-from-zotero) personal or group libraries.

3.  Searches of [Crossref](https://www.crossref.org/), [DataCite](https://datacite.org/), or [PubMed](https://pubmed.ncbi.nlm.nih.gov/).

4.  Your document bibliography (a `.bib` file in the directory of your document)

Under the hood, the visual mode uses the standard Pandoc markdown representation for citations (e.g., `[@citation]`).

If you add a citation using one of the first three methods, the visual editor will automatically create a `bibliography.bib` file for you and add the reference to it.
It will also add a `bibliography` field to the document YAML.
As you add more references, this file will get populated with their citations.
You can also directly edit this file using many common bibliography formats including BibLaTeX, BibTeX, EndNote, Medline.

To create a citation within your .qmd file in the source editor, use a key composed of '\@' + the citation identifier from the bibliography file.
Then place the citation in square brackets.
Here are some examples:

``` markdown
Separate multiple citations with a `;`: Blah blah [@smith04; @doe99].

You can add arbitrary comments inside the square brackets: 
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Remove the square brackets to create an in-text citation: @smith04 
says blah, or @smith04 [p. 33] says blah.

Add a `-` before the citation to suppress the author's name: 
Smith says blah [-@smith04].
```

When Quarto renders your file, it will build and append a bibliography to the end of your document.
The bibliography will contain each of the cited references from your bibliography file, but it will not contain a section heading.
As a result it is common practice to end your file with a section header for the bibliography, such as `# References` or `# Bibliography`.

You can change the style of your citations and bibliography by referencing a CSL (citation style language) file in the `csl` field:

``` yaml
bibliography: rmarkdown.bib
csl: apa.csl
```

As with the bibliography field, your csl file should contain a path to the file.
Here we assume that the csl file is in the same directory as the .qmd file.
A good place to find CSL style files for common bibliography styles is <https://github.com/citation-style-language/styles>.

## Workflow

Earlier, we discussed a basic workflow for capturing your R code where you work interactively in the *console*, then capture what works in the *script editor*.
Quarto brings together the console and the script editor, blurring the lines between interactive exploration and long-term code capture.
You can rapidly iterate within a chunk, editing and re-executing with Cmd/Ctrl + Shift + Enter.
When you're happy, you move on and start a new chunk.

Quarto is also important because it so tightly integrates prose and code.
This makes it a great **analysis notebook** because it lets you develop code and record your thoughts.
An analysis notebook shares many of the same goals as a classic lab notebook in the physical sciences.
It:

-   Records what you did and why you did it.
    Regardless of how great your memory is, if you don't record what you do, there will come a time when you have forgotten important details.
    Write them down so you don't forget!

-   Supports rigorous thinking.
    You are more likely to come up with a strong analysis if you record your thoughts as you go, and continue to reflect on them.
    This also saves you time when you eventually write up your analysis to share with others.

-   Helps others understand your work.
    It is rare to do data analysis by yourself, and you'll often be working as part of a team.
    A lab notebook helps you share not only what you've done, but why you did it with your colleagues or lab mates.

Much of the good advice about using lab notebooks effectively can also be translated to analysis notebooks.
We've drawn on our own experiences and Colin Purrington's advice on lab notebooks (<https://colinpurrington.com/tips/lab-notebooks>) to come up with the following tips:

-   Ensure each notebook has a descriptive title, an evocative file name, and a first paragraph that briefly describes the aims of the analysis.

-   Use the YAML header date field to record the date you started working on the notebook:

    ``` yaml
    date: 2016-08-23
    ```

    Use ISO8601 YYYY-MM-DD format so that's there no ambiguity.
    Use it even if you don't normally write dates that way!

-   If you spend a lot of time on an analysis idea and it turns out to be a dead end, don't delete it!
    Write up a brief note about why it failed and leave it in the notebook.
    That will help you avoid going down the same dead end when you come back to the analysis in the future.

-   Generally, you're better off doing data entry outside of R.
    But if you do need to record a small snippet of data, clearly lay it out using `tibble::tribble()`.

-   If you discover an error in a data file, never modify it directly, but instead write code to correct the value.
    Explain why you made the fix.

-   Before you finish for the day, make sure you can render the notebook.
    If you're using caching, make sure to clear the caches.
    That will let you fix any problems while the code is still fresh in your mind.

-   If you want your code to be reproducible in the long-run (i.e. so you can come back to run it next month or next year), you'll need to track the versions of the packages that your code uses.
    A rigorous approach is to use **renv**, <https://rstudio.github.io/renv/index.html>, which stores packages in your project directory.
    A quick and dirty hack is to include a chunk that runs `sessionInfo()` --- that won't let you easily recreate your packages as they are today, but at least you'll know what they were.

-   You are going to create many, many, many analysis notebooks over the course of your career.
    How are you going to organize them so you can find them again in the future?
    We recommend storing them in individual projects, and coming up with a good naming scheme.

## Summary

In this chapter we introduced you to Quarto for authoring and publishing reproducible computational documents that include your code and your prose in one place.
You've learned about writing Quarto documents in RStudio with the visual or the source editor, how code chunks work and how to customize options for them, how to include figures and tables in your Quarto documents, and options for caching for computations.
Additionally, you've learned about adjusting YAML header options for creating self-contained or parametrized documents as well as including citations and bibliography.
We have also given you some troubleshooting and workflow tips.

While this introduction should be sufficient to get you started with Quarto, there is still a lot more to learn.
Quarto is still relatively young, and is still growing rapidly.
The best place to stay on top of innovations is the official Quarto website: [https://quarto.org](https://quarto.org/){.uri}.

There are two important topics that we haven't covered here: collaboration and the details of accurately communicating your ideas to other humans.
Collaboration is a vital part of modern data science, and you can make your life much easier by using version control tools, like Git and GitHub.
We recommend "Happy Git with R", a user friendly introduction to Git and GitHub from R users, by Jenny Bryan.
The book is freely available online: <https://happygitwithr.com>.

We have also not touched on what you should actually write in order to clearly communicate the results of your analysis.
To improve your writing, we highly recommend reading either [*Style: Lessons in Clarity and Grace*](https://www.amazon.com/Style-Lessons-Clarity-Grace-12th/dp/0134080416) by Joseph M. Williams & Joseph Bizup, or [*The Sense of Structure: Writing from the Reader's Perspective*](https://www.amazon.com/Sense-Structure-Writing-Readers-Perspective/dp/0205296327) by George Gopen.
Both books will help you understand the structure of sentences and paragraphs, and give you the tools to make your writing more clear.
(These books are rather expensive if purchased new, but they're used by many English classes so there are plenty of cheap second-hand copies).
George Gopen also has a number of short articles on writing at <https://www.georgegopen.com/the-litigation-articles.html>.
They are aimed at lawyers, but almost everything applies to data scientists too.
