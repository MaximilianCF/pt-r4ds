# Quarto {#sec-quarto}

```{r}
#| echo: false

source("_common.R")
```

## Introduction

Quarto fornece uma estrutura (*framework*) unificada para autoria em ciência de dados, combinando seu código, seus resultados e sua prosa.
Documentos Quarto são plenamente reproduzíveis e suportam muitos formatos de saída como PDF, arquivos Word, apresentações e mais.

Arquivos Quarto foram projetados para serem usados de três maneiras:

1.  Para se comunicar com pessoas tomadoras de decisões, que querem focar nas conclusões e não no código por trás da análise.

2.  Para colaborar com outros cientistas de dados (incluindo futuramente você!) que estejam interessados tanto em suas conclusões quanto em como você as alcançou (isto é, o código).

3.  Como um ambiente em que se *faz* ciência de dados, como um caderno de laboratório moderno em que se pode capturar não apenas o que você fez, como também o que você estava pensando.

Quarto é uma feerramenta de linha de comando, não é um pacote do R.
Isso significa que ajuda, via de regra, não está disponível via `?`.
Em vez disso, enquanto você trabalhar neste capítulo e usa Quarto no futuro, você deve procurar a [documentação para Quarto](https://quarto.org).

Se você for uma pessoa que usa R Markdown, você deve estar pensando "Quarto parece muito com R Markdown".
Isso não está errado!
Quarto une a funcionalidade de muitos pacotes do ecosistema do R Markdown (rmarkdown, bookdown, distill, xaringan, etc.) em um sistema único e consistente, mas também extende o ecosistema com apoio nativo para múltiplas linguagens de programação como Python e Julia, além do próprio R.
De certa forma, Quarto reflete tudo que foi aprendido na expansão e suporte ao ecosistema do R Markdown em uma década.

### Pré-requisitos

Você precisa da interface de linha de comando Quarto (Quarto CLI -- *command line interface*), mas não é necessário explicitamente instalar ou carregá-la.
Seu RStudio o fará automaticamente quando for necessário.

```{r}
#| label: setup
#| include: false

chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
library(tidyverse)
```

## Básico de Quarto

Isso é um arquivo Quarto -- This is a Quarto file -- um arquivo de texto simples que possui a extensão `.qmd`:

```{r echo = FALSE, comment = ""}
cat(readr::read_file("quarto/diamond-sizes.qmd"))
```

O arquivo contém três tipos importantes de conteúdo:

1.  Um **cabeçalho YAML** (opcional) envolto por `---`.
2.  **Blocos** (ou *chunks*) de código R envoltos por ```` ``` ````.
3.  Texto misturado com formatação simples de texto como `# heading` and `_italics_` (respectivamente, para denotar um título ou marcar texto como itálico).

@fig-diamond-sizes-notebook mostra um documento `.qmd` no RStudio com interface de caderno, no qual código e saída são intercalados.
Você pode executar cada bloco de código clicando no ícone Executar -- *Run* (triângulo verde que parece com o botão de play no canto superior direito do bloco), ou pressionando Cmd/Ctrl + Shift + Enter.
O RStudio executará o código e mostrará os resultados junto com o código.

```{r}
#| label: fig-diamond-sizes-notebook
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio. Code and output interleaved in 
#|   the document, with the plot output appearing right underneath the code.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and a blank Viewer window on the right. The Quarto 
#|   document has a code chunk that creates a frequency plot of diamonds 
#|   that weigh less than 2.5 carats. The plot shows that the frequency 
#|   decreases as the weight increases.

knitr::include_graphics("quarto/diamond-sizes-notebook.png")
```

Se você não gosta de ver seus gráficos e saída dos códigos no documento e prefere usar os painéis de console e gráfico (aba *plot*), é possível clicar no ícone de roda dentada próximo ao botão "*Render*" e selecionar "*Chunk Output in Console*" (ou seja, resultados do chunk no console), conforme mostrado em @fig-diamond-sizes-console-output.

```{r}
#| label: fig-diamond-sizes-console-output
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio with the plot output in the Plots pane.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and the Plot pane on the bottom right. The Quarto 
#|   document has a code chunk that creates a frequency plot of diamonds 
#|   that weigh less than 2.5 carats. The plot is displayed in the Plot 
#|   pane and shows that the frequency decreases as the weight increases. 
#|   The RStudio option to show Chunk Output in Console is also 
#|   highlighted.

knitr::include_graphics("quarto/diamond-sizes-console-output.png")
```

Para produzir um relatório completo contendo todo o texto, código e resultados, clique em "Render" or pressione Cmd/Ctrl + Shift + K.
Você também pode fazer isso de programaticamente, em linha de código, com `quarto::quarto_render("diamond-sizes.qmd")`.
Isso exibirá o relatório no painel de visualização, como exibido em @fig-diamond-sizes-report, e cria um arquivo HTML.

```{r}
#| label: fig-diamond-sizes-report
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   A Quarto document in RStudio with the rendered document in the 
#|   Viewer pane.
#| fig-alt: |
#|   RStudio window with a Quarto document titled "diamond-sizes.qmd" 
#|   on the left and the Plot pane on the bottom right. The rendered 
#|   document does not show any of the code, but the code is visible 
#|   in the source document.

knitr::include_graphics("quarto/diamond-sizes-report.png")
```

Quando se gera ou renderiza o documento, Quarto envia o arquivo `.qmd` para o **knitr**, <https://yihui.org/knitr/>, que executa todos os blocos de código e cria um novo arquivo markdown (`.md`) que inclui o código e seus resultados.
O arquivo markgodn gerado pelo knitr é então processado pelo **pandoc**, [https://pandoc.org](https://pandoc.org/){.uri}, que é responsável por criar a versão final do arquivo.
Esse processo é ilustrado em @fig-quarto-flow.
A vantagem desse fluxo de trabalho em duas etapas é que é possível criar uma ampla variedade de formatos de arquivo, como você verá em @sec-quarto-formats.

```{r}
#| label: fig-quarto-flow
#| echo: false
#| out-width: "75%"
#| fig-alt: |
#|   Workflow diagram starting with a qmd file, then knitr, then md, 
#|   then pandoc, then PDF, MS Word, or HTML.
#| fig-cap: |
#|   Diagram of Quarto workflow from qmd, to knitr, to md, to pandoc, 
#|   to output in PDF, MS Word, or HTML formats.

knitr::include_graphics("images/quarto-flow.png")
```

Para iniciar seu próprio arquivo `.qmd`, selecione *File \> New File \> Quarto Document...* na barra de menu.
O RStudio abrirá uma janela em que você poderá preencher informações para pré-povoar seu arquivo com conteúdos úteis que lembra como os principais recursos do Quarto funcionam.

As seções a seguir aprofundam os três componentes de um documento Quarto em mais detalhes: o texto em markdown, os blocos de código e o cabeçalho YAML.

### Exercícios

1.  Crie um novo documento Quarto usando *File \> New File \> Quarto Document*.
    Leia as instruções.
    Pratique a execução dos blocos de código individualmente.
    Depois, renderize o documento clicando no botão designado e depois usando o atalho do teclado.
    Verifique se consegue alterar o código, rodá-lo novamente e ver o novo documento modificado.

2.  Crie um novo documento Quarto para cada um dos três formatos disponibilizados: HTML, PDF e Word.
    Renderize cada um dos três documentos.
    Qual é a diferença entre os resultados?
    Qual é a diferença entre os insumos?
    (É possível que seja necessário instalar o LaTeX para construir o arquivo PDF --- O RStudio avisará se isso for necessário.)

## Editor Visual

O editor Visual no RSTUDIO utiliza uma interface [WYSIWYM](https://en.wikipedia.org/wiki/WYSIWYM) para autoria de documentos Quarto.
Dembaixo do capô, prosa em documentos Quarto (arquivos `.qmd`) são escritos em Markdown, um conjunto leve de convenções para formatação de arquivos de texto simples.
De fato, Quarto usa markdown Pandoc (uma versão um pouco extendida de Markdown que é interpretável pelo Quarto), incluindo tabelas, citações, referências cruzadas, notas de rodapé, divs/spans, definiçòes de listas, atributos, HTML/TeX crús, entre outros, assim como suporta execução de células de código e a visualização de seus resultados em linha.
Enquanto Markdown é desenhado para ser simples de ler e escrever, como você verá em @sec-source-editor, ainda é necessário aprender uma nova sintaxe.
Assim, se documentos computacionais como arquivos `.qmd` são novos para você, mas você tem experiência com Google Docs ou MS Word, o jeito mais fácil de começar a usar Quarto no RStudio é pelo editor visual.

No editor visual, você pode tanto usar botões na barra de menu para inserir imagens, tabelas, referências cruzadas, etc. quanto usar o atalho geral <kbd>⌘ /</kbd> para inserir qualquer coisa.
Se você estiver no começo de uma linha (como ilustrado em @fig-visual-editor), você pode apenas digitar para <kbd>/</kbd> invocar o atalho.

```{r}
#| label: fig-visual-editor
#| echo: false
#| out-width: "75%"
#| fig-cap: |
#|   Quarto visual editor.
#| fig-alt: |
#|   A Quarto document displaying various features of the 
#|   visual editor such as text formatting (italic, bold, 
#|   underline, small caps, code, superscript, and subscript),
#|   first through third level headings, bulleted and numbered
#|   lists, links, linked phrases, and images (along with a 
#|   pop-up window for customizing image size, adding a 
#|   caption and alt text, etc.), tables with a header row, 
#|   and the insert anything tool with options to insert an 
#|   R code chunk, a Python code chunk, a div, a bullet list, 
#|   a numbered list, or a first level heading (the top few 
#|   choices in the tool).

knitr::include_graphics("quarto/quarto-visual-editor.png")
```

Inserir e personalizar como são exibidos também é facilitado com o uso do editor visual.
Você pode colar uma pasta diretamente da sua área de transferência no editor visual (e o RStudio colocará uma cópia daquela imagem no diretório do projeto e montarará um link para ela) ou usar o menu Insert \> Figure / Image do editor visual para navegar até a imagem desejada para inserir ou colar sua URL.
Além disso, usando o mesmo menu você pode redimensionar a imagem e aditionar uma legenda, texto alternativo e um link.

O editor visual tem muito mais recursos que não enumeramos aqui que podem ser úteis a você na medida em que você ganha experiência em escrever com a ferramenta.

Mais importante, enquanto o editor visual exibe o conteúdo do documento com formatação, por trás ele salva o conteúdo em Markdown, permitindo transitar entre o editor visual e de código (*source*) para visualizar e editar o documento usando qualquer uma das ferramentas.

### Exercícios

1.  Crie novamente o documento em @fig-visual-editor usando o editor visual.
2.  Usando o editor visual, insira um bloco de código usando o menu Insert e depois faça o mesmo usando qualquer ferramenta.
3.  Usando o editor visual, descubra como:
    a.  Adicionar uma nota de rodapé.
    b.  Adicionar uma linha horizontal.
    c.  Adicionar um bloco de citação.
4.  Usando o editor visual, vá em Insert \> Citation e insira a citação para o artigo cujo título é [Welcome to the Tidyverse](https://joss.theoj.org/papers/10.21105/joss.01686) usando o DOI (*digital object identifier*), que é [10.21105/joss.01686](https://doi.org/10.21105/joss.01686). Renderize o documento e observe como a referencia aparece no documento. Que alteração você consegue identificar no YAML do seu documento?

## Editor Source {#sec-source-editor}

Também é possível editar documentos Quarto usando o editor Source no RStudio, sem a assistência do editor visual.
Enquanto o editor Visual será familiar para aqueles com experiência em escrita com ferramentas como Google docs, o editor Source será familia para aqueles com experiência escrevendo scripts R ou documentos R Markdown.
O editor Source também pode ser útil para correções (*debugging*) qualquer erro de sintaxe Quarto, já que muitas vezes é mais fácil achar esses erros em texto simples.

O guia abaixo mostra como usar o Markdown do Pandoc para escrever documentos Quarto em seu editor fonte.

```{r}
#| echo: false
#| comment: ""

cat(readr::read_file("quarto/markdown.qmd"))
```

A melhor forma de aprender essas coisas é simplesmente tentar.
Isso levará alguns dias, mas em pouco tempo se tornam algo automático e não será necessário pensar tanto sobre elas.
Se você se esquecer, pode buscar uma boa folha de referência em *Help \> Markdown Quick Reference*.

### Exercícios

1.  Pratique o que você aprendeu criando um CV breve.
    O título deve ser o seu nome e você deve incluir cabeçalhos para pelo menos sua educação e trabalho.
    Cada uma das seções deve incluir uma lista em tópicos de trabalhos/títulos.
    Destaque o ano em negrito.

2.  Usando o editor fonte e a referência rápida para Markdown, descubra como:

    a.  Adicionar uma nota de rodapé.
    b.  ADicionar uma linha horizontal.
    c.  Adicionar um bloco de citação.

3.  Copie e cole o conteúdo de `diamond-sizes.qmd` a partir de <https://github.com/hadley/r4ds/tree/main/quarto> para um arquivo R Quarto local.
    Verifique se você consegue executá-lo, depois adicione texto depois do polígono de frequências que descreve suas características mais chamativas.

4.  Crie um documento em Google doc ou MS Word (ou localize um documento que você tenha criado previamente) que contenha títulos, hiperlinks, texto formatado, etc.
    Copie os conteúdos desse documento e cole-os em um documento quarto no editor visual.
    Em seguida, troque para o editor source e inspecion o código fonte.

## Blocos de Código

Para executar código em um documento Quarto, é necessário incluir um bloco de código.
Há três maneiras de fazer isso:

1.  O atalho de teclado Cmd + Option + I / Ctrl + Alt + I.

2.  O botão "Insert" na barra de ferramentas do editor.

3.  Escrevendo manualmente os limitadores de bloco ```` ```{r} ```` e ```` ``` ````.

Recomandamos que você aprenda o atalho de teclado.
Isso economizará muito tempo no longo prazo!

É possível prosseguir para a execução do código usando o atalho que agora (temos fé!) que você conhece e ama:Cmd/Ctrl + Enter.
No entanto, blocos recebem um novo atalho: Cmd/Ctrl + Shift + Enter, que executa todo o código no bloco.
Pense no bloco de código como uma função.
Um bloco deve ser relativamente autocontido, objetivando uma única tarefa.

As seções a seguir descrevem o cabeçalho do bloco, que consiste em ```` ```{r} ````, seguido de um rótulo opcional e diversas outras opções de bloco, cada uma em sua própria linha, marcada por `#|`.

### Rótulo de bloco

Blocos podem receber um rótulo opciona, por exemplo

```{r}
#| echo: fenced
#| label: simple-addition

1 + 1
```

Há três vantagens nisso:

1.  É possível navegar mais facilmente para blocos específicos usando o navegador em lista no canto inferior esquerdo do editor do script:

    ```{r}
    #| echo: false
    #| out-width: "30%"
    #| fig-alt: |
    #|   Snippet of RStudio IDE showing only the drop-down code navigator 
    #|   which shows three chunks. Chunk 1 is setup. Chunk 2 is cars and 
    #|   it is in a section called Quarto. Chunk 3 is pressure and it is in 
    #|   a section called Including plots.

    knitr::include_graphics("screenshots/quarto-chunk-nav.png")
    ```

2.  Gráficos produzidos pelos blocos terão nomes úteis para reutilizá-los em outros lugares.
    Mais sobre isso em @sec-figures.

3.  É possível organizar redes de bloco em cache para evitar múltiplas execuções de computações caras em toda execução.
    Mais sobre isso em @sec-caching.

Os rótulos dos seus blocos devem ser curtos, mas evocativos e não devem conter espaços.
Recomendamos o uso de traços (`-`) para separar palavras (em vez de sublinhados, `_`) e evitar o uso de outros caracteres especiais nos rótulos de código.

Em geral você é livre para rotular o bloco de código como quiser, mas há um bloco cujo nome indica um coportamento especial: `setup`.
Quando você está no modo caderno, o bloco com nome *setup* será executado automaticamente uma vez antes que todo o seu código seja executado.

Além disso,rótulos não podem ser duplicados.
Cada rótulo de bloco deve ser único.

### Opções de bloco

Saídas de bloco podem ser personalizadas com campos de opções (**options**) fornecidos para o cabeçalho do bloco.
Quase 60 opções para personalização dos seus blocos de código são fornecidas pelo Knitr.
Aqui cobriremos as opções mais importantes, que você utilizará com frequência.
É possível verificar a lista completa em [https://yihui.org/knitr/options](https://yihui.org/knitr/options/){.uri}.

O conjunto mais importante de opçòes controla se seu código será executado e que resultados serão exibidos no relatório final:

-   `eval: false` previne o código de ser avaliado.
    (E obviamente, se o código não é executado, nenhum resultado será gerado).
    Isso é útil para exibir um código de exemplo ou para desabilitar um grande bloco de código sem comentar cada uma de suas linhas.

-   `include: false` executa o código, mas não o mostra nem inclui seus resultados no documento final.
    Use isso para códigos de configurações cujos resultados você não quer que dêem uma aparência de desordem no seu relatório.

-   `echo: false` evita o código mas permite a exibição dos resultados no arquivo finalizado.
    Use isso quando estiver escrevendo relatórios direcionados a pessoas que não querem ver o código por trás dos resultados.

-   `message: false` ou `warning: false` previne o aparecimento de mensagens ou avisos no arquivo final.

-   `results: hide` esconde output; `fig-show: hide` esconde gráficos.

-   `error: true` permite a renderização contínua do seu documento mesmo que ocorra um erro.
    Você raramente precisará incluir isso na versão final do seu relatório, mas pode ser útil se você precisa corrigir um erro específico dentro do seu `.qmd`.
    Também é útil se você está ensinando R e quer incluir um erro deliberadamente.
    O padrão, `error: false` impede a renderização caso exista qualquer erro no documento.

Cada uma dessas opções de bloco é adicionada ao cabeçalho do bloco, seguindo `#|`, por exemplo, no bloco a seguir o resultado não é impresso, já que `eval` está marcado como *false*.

```{r}
#| echo: fenced
#| label: simple-multiplication
#| eval: false

2 * 2
```

A tabela a seguir resume que tipos de output cada opção suprime:

| Opção            | Executa código | Mostra código | Output | Gráficos | Mensagens | Avisos |
|------------------|:--------------:|:-------------:|:------:|:--------:|:---------:|:------:|
| `eval: false`    |       X        |               |   X    |    X     |     X     |   X    |
| `include: false` |                |       X       |   X    |    X     |     X     |   X    |
| `echo: false`    |                |       X       |        |          |           |        |
| `results: hide`  |                |               |   X    |          |           |        |
| `fig-show: hide` |                |               |        |    X     |           |        |
| `message: false` |                |               |        |          |     X     |        |
| `warning: false` |                |               |        |          |           |   X    |

### Opções Globais

Na medida em que você trabalhar mais com o knitr, você descobrirá que algumas das opções padrão dos blocos não satisfazem a sua necessidade e será preciso alterá-las.

É possível fazer isso adicionando suas opções preferidas no YAML do documento em `execute`.
Por exemplo, se você estiver preparando um relatório para uma audiência que não precisa ver seu código, mas apenas seus resultados e narrativa, pode ser que seja desejável configurar `echo: false` no nível do documento.
Isso esconderá o código por padrão e só exibirá blocos de código que você escolha mostrar ( com `echo: true`).
Você pode configurar `message: false` e `warning: false`, mas isso tornará difícil a resolução de problemas de execução porque nenhuma das mensagens srão exibidas no final do documento.

``` yaml
title: "My report"
execute:
  echo: false
```

Como Quarto foi desenhado para ser multi-línguas (funciona com R mas também com outras linguagens como Python, Julia, etc.), nem todas as opções do knitr estão disponíveis no nível de documento.
Algumas das opçoes funcionam com knitr mas não com outros motores (*engines*) que o Quarto usa para executar código em outras linguagens (por exemplo, Jupyter).
No entanto é possível ajustar essas como opções globais para o seu documento dentro do campo `knitr` em `opts_chunk`.
Por exemplo, quando escrevemos livros ou tutoriais, configuramos:

``` yaml
title: "Tutorial"
knitr:
  opts_chunk:
    comment: "#>"
    collapse: true
```

Isso faz com que nossa formatação para comentários preferida seja usada e garante que o código e seu resultado sejam exibidos próximos um do outro.

### Código em linha

Existe outra maneira de inserir código R em um documento Quarto: diretamente no texto com `r inline()`.
Isso pode ser muito útil se você for citar propriedades dos seus dados no texto.
Por exemplo, o documento modelo usado no começo do capítulo tinh:

> Temos dados sobre `r inline('nrow(diamonds)')` diamantes.
> Apenas `r inline('nrow(diamonds) - nrow(smaller)')` são maiores que 2.5 carates.
> A distribuição dos restantes é exibida abaixo:

Quando o relatório é renderizado, os resultados dessas computações são inseridas no texto:

> Temos dados sobre 53940 diamantes.
> Apenas 126 são maiores que 2.5 carates.
> A distribuição dos restantes é exibida abaixo:

Ao inserir números no texto, `format()` é seu amigo.
A função permite configurar o número de `digits` (casas decimais) para que você não imprima o número com uma precisão ridícula e `big.mark` para facilitar a leitura dos números.
Você pode combiná-las em uma função auxiliar:

```{r}
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.12358124331)
```

### Exercícios

1.  Adicione uma seção que explore como o tamanho de diamantes varia de acordo com corte, cor e claridade.
    Considere que você está escrevendo um relatório para alguém que não sabe R e em vez de usar `echo: false` em cada bloco, configure como uma opção global.

2.  Faça o download de `diamond-sizes.qmd` de <https://github.com/hadley/r4ds/tree/main/quarto>.
    Adicione uma seção que descreva os 20 maiores diamantes, incluindo uma tabela que mostre seus atributos mais importantes.

3.  Modifique `diamonds-sizes.qmd` para usar `label_comma()` e produzir output bem formatado.
    Inclua tam´bme a percentagem de diamantes que são maiores que 2.5 carates.

## Figuras {#sec-figures}

As figuras em um documento Quarto podem ser integradas (como um arquivo PNG ou JPEG) ou geradas como resultado de um bloco de código.

Para integrar uma imagem a partir de um arquivo externo, é possível usar o menu Insert no editor Visual no RStudio e selecionar Figure / Image.
Isso abrirá um menu em que é possível buscar a imagem que você deseja inserir, assim como adicionar um texto alternativo ou legenda e ajustar seu tamanho.

No editor visual também é possível simplesmente colar uma imagem da sua área de transferência no documento, então o RStudio inserirá uma cópia daquela imagem na pasta do seu projeto.

Se você incluir um bloco de código que gera uma figura (como uma chamada a `ggplot()`), a imagem resultante será automaticamente incluída no seu documento Quarto.

### Tamanho de figura

O maior desafio ao trabalhar com imagens no Quarto é fazer com que elas fiquem do tamanho e no formato corretos.
Há cinco opções principais que controlam o tamanho da figura: `fig-width`, `fig-height`, `fig-asp`, `out-width` e `out-height`.
Ajustar o tamanho é desafiador porque há dois tamanhos (aquele da figura criada pelo R e aquele que é inserido no documento final) e múltiplas formas de especificar tamanho (isto é, altura, largura e proporcional ou *aspect ratio*: escolha dois dos três).

Recomendamos três das cinco opções:

-   Gráficos tendem a ser esteticamente mais agradáveis se têm largura consistente.
    Para garantir isso, configure `fig-width: 6` (6 polegadas) and `fig-asp: 0.618` (a razão áurea) nas definições padrão.
    Nos blocos individuais, ajuste apenas `fig-asp`.

-   Controle o tamanho da saída com `out-width` e configure como uma percentagem da largura do corpo do documento.
    Sugerimos `out-width: "70%"` e `fig-align: center`.

    Isso dá espaço para os gráficos respirarem, sem tomar espaço demais.

-   Para inserir múltiplos gráficos na mesma linha, configure `layout-ncol` em 2 para dois gráficos, 3 para três gráficos, etc.
    Isso efetivamente ajusta `out-width` para "50%" para cada gráfico se `layout-ncol` for 2, "33%" se `layout-ncol` for 3, etc.
    Dependendo do que você está tentando ilustrar (por exemplo, mostrar dados ou variações de gráficos), você pode experimentar ajustar também `fig-width` conforme a discussão a seguir.

Se você perceber que está precisando apertar os olhos para enxergar o texto no seu gráfico, você precisa ajustar o `fig-width`.
Se `fig-width` é maior que o tamanho da figura renderizada no documento final, o texto ficará muito pequeno; se `fig-width` for menor, o texto ficará grande demais.
Frequentemente será necessário alguma experimentação para acertar a razão entre `fig-width` e a largura do seu documento.
Para ilustrar, os três gráficos a seguir têm `fig-width` de 4, 6, e 8 respectivamente:

```{r}
#| include: false

plot <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()
```

```{r}
#| echo: false
#| fig-width: 4
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are normally sized and the axis text and labels are in similar font size 
#|   to the surrounding text.

plot
```

```{r}
#| echo: false
#| fig-width: 6
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are smaller than in the previous plot and the axis text and labels are 
#|   smallter than the surrounding text.

plot
```

```{r}
#| echo: false
#| fig-width: 8
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, where the points 
#|   are even smaller than in the previous plot and the axis text and labels are 
#|   even smallter than the surrounding text.

plot
```

Se você quiser garantir que o tamanho da fonte é consistente em todas as suas figuras, será necessário ajustar sempre o `out-width` com o `fig-width` para manter a mesma razão com o `out-width` padrão.
Por exemplo, se seu `fig-width` padrão é 6 e o `out-width` está em "70%", será necessário configurar `fig-width` a 4.3 (6 \* 0.5 / 0.7) quando ajustar `out-width: "50%"`.

Entender dimensionamento é uma arte e uma ciência e acertar essas coisas pode requerer uma abordagem de tentativa e erro Você pode aprender mais sobre isso no [post de blog tomando controle de dimensionamento de gráficos](https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/).

### Outras opções importantes

Quando estamos trabalhando com código e text, como neste livro, é possível ajustar `fig-show: hold` de modo que os gráficos são exibidos após o código.
Isso rende o efeito agradável de nos forçar a quebrar blocos de código grandes em menores com suas explicações.

Para adicionar uma legenda ao gráfico, use `fig-cap`.
No Quarto isso mudará a figura de *inline* (no meio do texto) para "*floating*".

Se você está produzindo PDF, o tipo gráfico padrão é PDF.
Isso é um bom padrão porque PDF são gráficos vetoriais de alta qualidade.
No entanto, isso pode gerar gráficos muito grandes e lentos se você está exibindo milhares de pontos.
Nesse caso, ajusete `fig-format: "png"` para forçar o uso de PNGs.
Esses têm qualidade ligeiramente menor, mas são muito mais compactos.

É uma boa ideia dar rótulos a blocos de código que produzam figuras, mesmo que você rotineiramente não faça isso.
O rótulo do bloco é usado para gerar o nome de arquivo do gráfico em disco, então nomear seus blocos facilita muito a identificação dos gráficos e reutilizá-lose em outras circunstâncias (por exemplo, quando é necessário pegar um único gráfico para enviar um email).

### Exercícios

1.  Abra `diamond-sizes.qmd` no editor visual, ache uma imagem de diamante, copie e cole no documento.
    Clique duas vezes na imagem e adicione uma legenda.
    Redimensione a imagem e renderize o documento.
    Observe como a imagem é salva no seu diretório de trabalho.

2.  Edite o rótulo do bloco de código em `diamond-sizes.qmd` que gera um gráfico para que comece com o prefixo `fig-` e adicione uma legenda à figura com a opção de bloco `fig-cap`.
    Em seguida, edite o texto acima do bloco de código e adicione uma referência cruzada para a figura com Insert \> Cross Reference.

3.  Mude o tamanho da figura com as seguintes opçòes de bloco, uma por vez, renderize o documento e descreva como a figura muda.

    a.  `fig-width: 10`

    b.  `fig-height: 3`

    c.  `out-width: "100%"`

    d.  `out-width: "20%"`

## Tabelas

Similar a figuras, é possível incluir dois tipos de tabelas em um documento Quarto.
Elas podem ser tabelas markdown que você pode criar diretamente em seu documento Quarto (usando o menu Insert Table) ou podem ser geradas como resultado de um bloco de código.
Nesta seção focaremos na segunda, tabelas geradas via computação.

Por padrão, Quarto imprime *data frames* e matrizes como você as veria no console:

```{r}
mtcars[1:5, ]
```

Se voce pre preferir que os dados sejam expostos com formatação adicional, você pode usar a função `knitr::kable()`.
O código abaixo gera @tbl-kable.

```{r}
#| label: tbl-kable
#| tbl-cap: A knitr kable.

knitr::kable(mtcars[1:5, ], )
```

Leia a documentação para `?knitr::kable` para ver de que outras formas você pode personalizar a sua tabela.
Para uma personalização ainda mais profunda, considere os pacotes **gt**, **huxtable**, **reactable**, **kableExtra**, **xtable**, **stargazer**, **pander**, **tables**, e **ascii**.
Cada um fornece um conjunto de ferramentas para retornar tabelas formatadas a partir de código R.

### Exercícios

1.  Abra `diamond-sizes.qmd` no editor visual, insira um bloco de código e adicione uma tabela com `knitr::kable()` que mostre as 5 primeiras linhas do *data frame* `diamonds`.
2.  Exiba a mesma tabela com `gt::gt()`.
3.  Adicione um rótulo de bloco de código que começa com o prefixo `tbl-` e adicione a legenda para a tabela com a opção de bloco `tbl-cap`. Depois edite o texto acima do bloco de código para adicionar a referência cruzada para a tabela com Insert \> Cross Reference.

## Salvando em cache {#sec-caching}

Normalmente, cada renderização do documento começa com uma folha em branco.
Isso é ótimo para reproducibilidade porque garante que você capturou toda computação importante em código.
No entanto, pode ser doloroso refazer computações que tomam um tempo longo.
A solução para isso é `cache: true`.

É possível habilitar o cache do knitr no nível do documento para guardar em cache os resultados de todas as computações em um documento usando as opções padrão de YAML:

``` yaml
---
title: "Meu documento"
execute: 
  cache: true
---
```

Também é possível permitir *caching* no nível de bloco para guardar os resultados da computação de um bloco específico em cache.

```{r}
#| echo: fenced
#| cache: true

# código para uma computação longa...
```

Quando configurado, isso salvará os resultados do bloc para um arquivo de nome especial em seu disco de armazenamento.
Em execuções subsequentes, knitr verificará se houve alguma alteração no código e caso isso não tenha acontecido os resultados em cache serão reutilizados.

O sistema de cache deve ser usado com cuidado porque, por padrão, é usado apenas no código em não em suas dependências.
Por exemplo, aqui o bloco `processed_data` depende do bloco `raw-data`:

````         
``` {{r}}
#| label: raw-data
#| cache: true

rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

````         
``` {{r}}
#| label: processed_data
#| cache: true

processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

Guardar o bloco `processed_data` em cache signigica que ele será executado novamente se o *pipeline* de dplyr for alterado, mas não se a chamada de `read_csv()` mudar.
Esse problema pode ser evitado com a opção `dependson`:

````         
``` {{r}}
#| label: processed-data
#| cache: true
#| dependson: "raw-data"

processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

`dependson` deve conter um vetor de caracteres em *todos* os blocos de que o bloco em cache depende.
Knitr atualizará os resultados para o bloco em cache sempre que detectar que uma de suas dependências mudou.

Note que os blocos não serão atualizados se `a_very_large_file.csv` mudar, já que o cache do knitr só monitora alterações no arquivo `.qmd`.
Se você quiser também monitorar mudanças naquele arquivo, é possível usar a opção `cache.extra`.
Essa é uma expressão de R arbitrária que invalida o cache toda vez que há alteração.
Uma boa função neste caso é `file.mtime()`: a função retorna quando foi a última alteração.
Você pode então escrever:

````         
``` {{r}}
#| label: raw-data
#| cache: true
#| cache.extra: !expr file.mtime("a_very_large_file.csv")

rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

Seguimos o conselho de [David Robinson](https://twitter.com/drob/status/738786604731490304) para nomear esses blocos: cada um é nomeado de acordo com o objeto primário que é criado.
Isso facilita a compreensão da especificação de `dependson`.

Na medida em que suas estratégias de cache vão complicando, é uma boa ideia limpar todo o seu cache com `knitr::clean_cache()`.

### Exercícios

1.  Ajuste uma rede de blocos em que `d` depende de `c` e `b` e os dois últimos dependem de `a`. Faça com que cada bloco imprima `lubridate::now()`, ajuste `cache: true` e verifique o que você entendeu sobre *caching*.

## Resolução de problemas

Resolver problemas em documentos Quarto pode ser desafiador porque você não está mais em um ambiente interativo de R, então você precisará aprender uns truques novos.
Além disso, o erro pode ter ocorrido devido a problemas no documento de Quarto ou mesmo devido ao código em R no documento.

Um erro comum em documentos com blocos de código é haver rótulos de blocos duplicados, o que tem certa ocorrência se o seu fluxo de trabalho envolve cópia e cola de blocos de código.
Para abordar esse problema, tudo que você precisa fazer é mudar o nome de um dos seus rótulos duplicados.

Se os erros ocorrem por causa do código em R no documento, a primeira coisa que você deveria fazer sempre é tentar recriar o problema em uma sessão interativa.
Reinicie o R, depois execute todos os blocos (*Run all chunks*) via *Run region* no menu Code ou com o atalho Ctrl + Alt + R.
Se estiver com sorte, isso recriará o problema e você descobrirá o que está acontecendo interativamente.

Se isso não ajudar, deve haver algo diferente entre o seu ambiente interativo e o seu ambiente Quarto.
Será necessário explorar as opções sistematicamente.
A diferença mais comum é o diretório de trabalho: o diretório de trabalho de um documento Quarto é aquele em que o documento vive.
Verifique se o diretório é o que você espera usando `getwd()` em um bloco.

A seguir, tente listar todas as coisas que poderiam causar o *bug*.
Será necessário verificar sistematicamente se essas coisas são as mesmas na sua sessão R e na sua sessão Quarto.
A forma mais fácil de fazer isso é ajustar `error:true` no bloco causando o problema e usar `print()` e `str()` para verificar que as configurações são o que você espera.

## Cabeçalho YAML

É possível controlar muitas outras configurações de "documento inteiro" ajustando os parâmetros do cabeçalho YAML.
Você pode estar pensando no que significa YAML: é "*YAML Ain't Markup Language*" ou "YAML não é linguagem Markup" -- mas não carrega a sigla em português.
A linguagem foi projetada para representar dado hierárquico de uma forma que fosse fácil para humanos lerem e escreverem.
Quarto usa isso para controlar muitos detalhes da saída.
Aqui discutiremos três: documentos autocontidos, parâmetros de documentos e bibliografias.

### Documentos Autocontidos

Documentos HTML tipicamente têm uma série de dependências externas (por exemplo imagens, guias de estilo CSS, JavaScript, etc.) e, por padrão, Quarto coloca essas dependências em uma pasta `_files` no mesmo diretório que o seu arquivo `.qmd`.
Se você publicar o arquivo HTML em uma plataforma (por exemplo, QuartoPub, <https://quartopub.com/>), as dependências desse diretório são publicadas com o documento e então estarão disponíveis no relatório publicado.
No entanto, se você quer enviar o relatório para um colega por email, é possível que prefira ter um único documento HTML autocontido que tem suas dependências todas embutidas.
Você pode fazer isso especificando a opção `embed-resources`.

``` yaml
format:
  html:
    embed-resources: true
```

O arquivo resultante será autocontido, de modo que não necessitará de qualquer arquivo interno nem de acesso à internet para ser exibido corretamente por um navegador.

### Parâmetros

Documentos Quarto podem incluir um ou mais parâmetros cujos valores podem ser ajustados quando se renderiza o relatório.
Parâmetros são úteis quando se quer executar mais vezes o mesmo relatório com valores diferentes para vários inputs chave.
Por exemplo, pode ser que seja necessário produzir relatórios de vendas por escritório, resultados de provas por aluno ou mesmo resumos demográficos por mais.
Para declarar um ou mais parâmetros, use o campo `params`.

Esse exemplo usa o parâmetro `my_class` para determinar que classe de carros será exibida:

```{r}
#| echo: false
#| out-width: "100%"
#| comment: ""

cat(readr::read_file("quarto/fuel-economy.qmd"))
```

Como se pode ver, parâmetros estão disponíveis dentro dos blocos de código como uma lista chamada `params` com permissão apenas de leitura.

É possível escrever vetores atômicos diretamente no cabeçalho YAML.
É possível ainda executar expressões arbitrárias em R prefixando o valor do parâmetro com `!expr`.
Essa é uma boa forma de especificar patâmetros de data/tempo.

``` yaml
params:
  start: !expr lubridate::ymd("2015-01-01")
  snapshot: !expr lubridate::ymd_hms("2015-01-01 12:30:00")
```

### Bibliografias e citações

Bibliografia e citações podem ser automaticamente geradas pelo Quarto em uma série de estilos.
A forma mais direta de adicionar citações e bibliografias no seu documento Quarto é usando o editor visual no RStudio.

Para adicionar a citação no editor visual, vá em Insert \> Citation.
Citaçòes podem ser inseridas a partir de uma variedade de fontes:

1.  Referências [DOI](https://quarto.org/docs/visual-editor/technical.html#citations-from-dois) (*Document Object Identifier*).

2.  Bibliotecas particulares ou de grupo do [Zotero](https://quarto.org/docs/visual-editor/technical.html#citations-from-zotero) personal.

3.  Pesquisas na [Crossref](https://www.crossref.org/), [DataCite](https://datacite.org/), ou na [PubMed](https://pubmed.ncbi.nlm.nih.gov/).

4.  Seu documento de bibliografia (um arquivo `.bib` no diretório do seu documento)

Dentro do capô, o editor visual usa a representação padrão para citações do markdown Pandoc, (por exemplo, `[@citation]`).

Se você inserir uma citação usando um dos primeiros três métodos, o editor visual automaticamente criará um arquivo `bibliography.bib` para você e adicionará a sua referência a ele.
Isso também adicionará um campo `bibliography` ao YAML do documento Na medida em que você insere mais referências, esse arquivo é povoado com as citações.
Também é possivel editar diretamente esse arquivo usando muitos formatos comuns como BibLaTeX, BibTeX, EndNote, Medline.

Para criar a citação dentro do seu arquivo `.qmd` no editor fonte, use a chave composta de '\@' + identificador da citação do seu arquivo de bibliografia.
Em seguida, coloque a citação entre colchetes.
Seguem alguns exemplos:

``` markdown
Separate multiple citations with a `;`: Blah blah [@smith04; @doe99].

You can add arbitrary comments inside the square brackets: 
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Remove the square brackets to create an in-text citation: @smith04 
says blah, or @smith04 [p. 33] says blah.

Add a `-` before the citation to suppress the author's name: 
Smith says blah [-@smith04].
```

When Quarto renders your file, it will build and append a bibliography to the end of your document.
The bibliography will contain each of the cited references from your bibliography file, but it will not contain a section heading.
As a result it is common practice to end your file with a section header for the bibliography, such as `# References` or `# Bibliography`.

You can change the style of your citations and bibliography by referencing a CSL (citation style language) file in the `csl` field:

``` yaml
bibliography: rmarkdown.bib
csl: apa.csl
```

As with the bibliography field, your csl file should contain a path to the file.
Here we assume that the csl file is in the same directory as the .qmd file.
A good place to find CSL style files for common bibliography styles is <https://github.com/citation-style-language/styles>.

## Workflow

Earlier, we discussed a basic workflow for capturing your R code where you work interactively in the *console*, then capture what works in the *script editor*.
Quarto brings together the console and the script editor, blurring the lines between interactive exploration and long-term code capture.
You can rapidly iterate within a chunk, editing and re-executing with Cmd/Ctrl + Shift + Enter.
When you're happy, you move on and start a new chunk.

Quarto is also important because it so tightly integrates prose and code.
This makes it a great **analysis notebook** because it lets you develop code and record your thoughts.
An analysis notebook shares many of the same goals as a classic lab notebook in the physical sciences.
It:

-   Records what you did and why you did it.
    Regardless of how great your memory is, if you don't record what you do, there will come a time when you have forgotten important details.
    Write them down so you don't forget!

-   Supports rigorous thinking.
    You are more likely to come up with a strong analysis if you record your thoughts as you go, and continue to reflect on them.
    This also saves you time when you eventually write up your analysis to share with others.

-   Helps others understand your work.
    It is rare to do data analysis by yourself, and you'll often be working as part of a team.
    A lab notebook helps you share not only what you've done, but why you did it with your colleagues or lab mates.

Much of the good advice about using lab notebooks effectively can also be translated to analysis notebooks.
We've drawn on our own experiences and Colin Purrington's advice on lab notebooks (<https://colinpurrington.com/tips/lab-notebooks>) to come up with the following tips:

-   Ensure each notebook has a descriptive title, an evocative file name, and a first paragraph that briefly describes the aims of the analysis.

-   Use the YAML header date field to record the date you started working on the notebook:

    ``` yaml
    date: 2016-08-23
    ```

    Use ISO8601 YYYY-MM-DD format so that's there no ambiguity.
    Use it even if you don't normally write dates that way!

-   If you spend a lot of time on an analysis idea and it turns out to be a dead end, don't delete it!
    Write up a brief note about why it failed and leave it in the notebook.
    That will help you avoid going down the same dead end when you come back to the analysis in the future.

-   Generally, you're better off doing data entry outside of R.
    But if you do need to record a small snippet of data, clearly lay it out using `tibble::tribble()`.

-   If you discover an error in a data file, never modify it directly, but instead write code to correct the value.
    Explain why you made the fix.

-   Before you finish for the day, make sure you can render the notebook.
    If you're using caching, make sure to clear the caches.
    That will let you fix any problems while the code is still fresh in your mind.

-   If you want your code to be reproducible in the long-run (i.e. so you can come back to run it next month or next year), you'll need to track the versions of the packages that your code uses.
    A rigorous approach is to use **renv**, <https://rstudio.github.io/renv/index.html>, which stores packages in your project directory.
    A quick and dirty hack is to include a chunk that runs `sessionInfo()` --- that won't let you easily recreate your packages as they are today, but at least you'll know what they were.

-   You are going to create many, many, many analysis notebooks over the course of your career.
    How are you going to organize them so you can find them again in the future?
    We recommend storing them in individual projects, and coming up with a good naming scheme.

## Resumo

Neste capítulo introduzimos Quarto para escrita e publicação reproduzível de documentos computacionais que incluem seu código e sua prosa no mesmo lugar.
Você aprender a escrever em documentos Quarto no RStudio com o editor fonte ou visual, como blocos de código funcionam e como personalizar opções para cache de computações.
Além disso, você aprendeu sobre ajustes no cabeçalho YAML para criar documentos autocontidos ou parametrizados, assim como sobre citações e bibliografia.
Também demos dicas de fluxo de trabalho e resolução de problemas.

Enquanto essa introdução deve ser suficiente para iniciar seu trabalho com Quarto, ainda há muito a aprender.
Quarto ainda é relativamente jovem e ainda está crescendo rapidamente.
O melhor lugar para se atualizar das últimas inovações é o site oficial: [https://quarto.org](https://quarto.org/){.uri}.

Há dois tópicos importantes que não cobrimos aqui: colaboração e detalhes para comunicar sua ideia com precisão para outros humanos.
Colaboração é parte vital da ciência de dados moderna e você pode facilitar muito a vida usando ferramentas de controle de versão, como Git e Github.
Recomendamos "Happy Git with R", uma introdução amigável a Git e Github de usuários de R, por Jenny Bryan.
O livro está disponível online com acesso livre: <https://happygitwithr.com>.

Também não comentamos sobre o que você deveria realmente escrever para comunicar seus resultados da sua análise com clareza.
Para melhorar sua escrita, recomendamos muito a leitura de [*Style: Lessons in Clarity and Grace*](https://www.amazon.com/Style-Lessons-Clarity-Grace-12th/dp/0134080416) por Joseph M. Williams & Joseph Bizup, ou [*The Sense of Structure: Writing from the Reader's Perspective*](https://www.amazon.com/Sense-Structure-Writing-Readers-Perspective/dp/0205296327) by George Gopen.
Ambos os livros ajudarão a entender a estrutura de frases e parágrafos e darão gerramentas para tornar sua escrita mais clara.
(esses livros são um tanto caros, mas são muito usados em cursos de inglês, então há muitas cópias baratas de segunda mão).
George Gopen também tem uma série de artigos curtos sobre escrita em <https://www.georgegopen.com/the-litigation-articles.html>.
Esses são direcionados a advogados, mas quase tudo se aplica a cientistas de dados também.
